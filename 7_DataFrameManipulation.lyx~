#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Manipulating Data Frames
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

opts_chunk$set(cache.path = './cache/DataManipulation/',
\end_layout

\begin_layout Plain Layout

               fig.path   = './figure/DataManipulation/')
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset

Most of the time, our data is in the form of a data frame and we are interested
 in exploring the relationships.
 This chapter explores how to manipulate data frames and methods.
 
\end_layout

\begin_layout Section
Classical functions for summarizing rows and columns
\end_layout

\begin_layout Subsection
summary()
\end_layout

\begin_layout Standard
The first method is to calculate some basic summary statistics (minimum,
 25th, 50th, 75th percentiles, maximum and mean) of each column.
 If a column is categorical, the summary function will return the number
 of observations in each category.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# use the iris data set which has both numerical and categorical variables
\end_layout

\begin_layout Plain Layout

data( iris )
\end_layout

\begin_layout Plain Layout

str(iris)    # recall what columns we have 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# display the summary for each column
\end_layout

\begin_layout Plain Layout

summary( iris )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
apply()
\end_layout

\begin_layout Standard
The summary function is convenient, but we want the ability to pick another
 function to apply to each column and possibly to each row.
 To demonstrate this, suppose we have data frame that contains students
 grades over the semester.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Chunk
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# make up some data
\end_layout

\begin_layout Plain Layout

grades <- data.frame(
\end_layout

\begin_layout Plain Layout

  l.name = c('Cox', 'Dorian', 'Kelso', 'Turk'),
\end_layout

\begin_layout Plain Layout

  Exam1 = c(93, 89, 80, 70),
\end_layout

\begin_layout Plain Layout

  Exam2 = c(98, 70, 82, 85),
\end_layout

\begin_layout Plain Layout

  Final = c(96, 85, 81, 92) )
\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

The 
\family typewriter
apply()
\family default
 function will apply an arbitrary function to each row (or column) of a
 matrix or a data frame and then aggregate the results into a vector.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# Because I can't take the mean of the last names column,
\end_layout

\begin_layout Plain Layout

# remove the name column
\end_layout

\begin_layout Plain Layout

scores <- grades[,-1]
\end_layout

\begin_layout Plain Layout

scores
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Summarize each column by calculating the mean.
\end_layout

\begin_layout Plain Layout

apply( scores,      # what object do I want to apply the function to
\end_layout

\begin_layout Plain Layout

       MARGIN=2,    # rows = 1, columns = 2, (same order as [rows, cols]
\end_layout

\begin_layout Plain Layout

       FUN=mean     # what function do we want to apply     
\end_layout

\begin_layout Plain Layout

     )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

To apply a function to the rows, we just change which margin we want.
 We might want to calculate the average exam score for person.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

apply( scores,      # what object do I want to apply the function to
\end_layout

\begin_layout Plain Layout

       MARGIN=1,    # rows = 1, columns = 2, (same order as [rows, cols]
\end_layout

\begin_layout Plain Layout

       FUN=mean     # what function do we want to apply
\end_layout

\begin_layout Plain Layout

     )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

This is useful, but it would be more useful to concatenate this as a new
 column in my 
\family typewriter
grades
\family default
 data frame.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

average <- apply( 
\end_layout

\begin_layout Plain Layout

  scores,      # what object do I want to apply the function to
\end_layout

\begin_layout Plain Layout

  MARGIN=1,    # rows = 1, columns = 2, (same order as [rows, cols]
\end_layout

\begin_layout Plain Layout

  FUN=mean     # what function do we want to apply
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

grades <- cbind( grades, average )
\end_layout

\begin_layout Plain Layout

grades
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

There are several variants of the 
\family typewriter
apply()
\family default
 function, and the variant I use most often is the function 
\family typewriter
sapply()
\family default
, which will apply a function to each element of a list or vector and returns
 a corresponding list or vector of results.
 
\end_layout

\begin_layout Section
Package 
\family typewriter
dplyr
\end_layout

\begin_layout Standard
Many of the tools to manipulate data frames in R were written without a
 consistent syntax and are difficult use together.
 To remedy this, Hadley Wickham (the writer of 
\family typewriter
ggplot2
\family default
) introduced a package called 
\family typewriter
plyr
\family default
 which was quite useful.
 As with many projects, his first version was good but not great and he
 introduced an improved version that works exclusively with 
\family typewriter
data.frames
\family default
 called 
\family typewriter
dplyr
\family default
 which we will investigate.
 The package 
\family typewriter
dplyr
\family default
 strives to provide a convenient and consistent set of functions to handle
 the most common data frame manipulations and a mechanism for chaining these
 operations together to perform complex tasks.
 
\end_layout

\begin_layout Standard
The author of the 
\family typewriter
dplyr
\family default
 package has put together a very nice introduction to the package that explains
 in more detail how the various pieces work and I encourage you to read
 it at some point.
 
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset href
LatexCommand href
target "http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html"

\end_inset

.
\end_layout

\begin_layout Standard
The pipe command 
\family typewriter
%>%
\family default
 allows for very readable code.
 The idea is that the 
\family typewriter
%>%
\family default
 operator works in the context of functions that take a 
\family typewriter
data.frame
\family default
 as their first argument.
 The 
\family typewriter
%>%
\family default
 operator translates 
\family typewriter
df %>% f()
\family default
 to the expression 
\family typewriter
f(df)
\family default
.
 The beauty of this comes when you have functions that takes 
\family typewriter
data.frames
\family default
 as arguments and returns a modified 
\family typewriter
data.frame
\family default
.
 This will allow me to chain together commands in a readable fashion.
\end_layout

\begin_layout Subsection
Verbs
\end_layout

\begin_layout Standard
The foundational operations to perform on a data frame are:
\end_layout

\begin_layout Itemize
Subsetting - Returns a 
\family typewriter
data.frame
\family default
 with only particular columns or rows
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
select
\family default
 - Selecting a subset of columns by name or column number.
\end_layout

\begin_layout Itemize

\family typewriter
filter
\family default
 - Selecting a subset of rows from a data frame based on logical expressions.
\end_layout

\begin_layout Itemize

\family typewriter
slice
\family default
 - Selecting a subset of rows by row number.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
arrange
\family default
 - Re-ordering the rows of a data frame.
\end_layout

\begin_layout Itemize

\family typewriter
mutate
\family default
 - Add a new column that is some function of another column.
\end_layout

\begin_layout Itemize

\family typewriter
summarise
\family default
 - calculate some summary statistic of a column of data.
 This collapses a set of rows into a single row.
\end_layout

\begin_layout Standard
Each of these operations is a function in the package 
\family typewriter
dplyr
\family default
.
 These functions all have a similar calling syntax, the first argument is
 a data frame, subsequent arguments describe what to do with the input data
 frame and you can refer to the columns without using the 
\family typewriter
df$column
\family default
 notation.
 All of these functions will return a data frame.
\end_layout

\begin_layout Subsubsection
Subsetting with 
\family typewriter
select
\family default
, 
\family typewriter
filter
\family default
, and 
\family typewriter
slice
\end_layout

\begin_layout Standard
These function allows you select certain columns and rows of a data frame.
\end_layout

\begin_layout Subsubsection*

\series bold
select()
\series default
 
\end_layout

\begin_layout Standard
Often you only want to work with a small number of columns of a data frame.
 It is relatively easy to do this using the standard 
\family typewriter
[,col.name]
\family default
 notation, but is often pretty tedious.
 The dataset 
\family typewriter
mtcars
\family default
 contains information about 32 models of cars from the 70s.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<message=FALSE>>=
\end_layout

\begin_layout Plain Layout

library(dplyr)
\end_layout

\begin_layout Plain Layout

str(mtcars)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

I could select the columns 
\family typewriter
mpg,
\family default
 
\family typewriter
cyl,
\family default
 
\family typewriter
disp,
\family default
 
\family typewriter
hp
\family default
 by hand, or by using an extension of the 
\family typewriter
:
\family default
 operator
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

small <- mtcars %>% select( mpg, cyl, disp, hp )  # these two commands are
 
\end_layout

\begin_layout Plain Layout

small <- mtcars %>% select( mpg:hp )              # equivalent
\end_layout

\begin_layout Plain Layout

str(small)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*

\series bold
filter()
\series default
 
\end_layout

\begin_layout Standard
It is common to want to select particular rows where we have some logically
 expression to pick the rows.
\begin_inset Newline newline
\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# recall what the grades are
\end_layout

\begin_layout Plain Layout

grades
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<message=FALSE, warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

# select students with Final grades greater than 90
\end_layout

\begin_layout Plain Layout

grades %>% filter(Final > 90)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

You can have multiple logical expressions to select rows and they will be
 logically combined so that only rows that satisfy 
\series bold
all
\series default
 of the conditions are selected.
\begin_inset Foot
status open

\begin_layout Plain Layout
The logicals are joined together using 
\family typewriter
&
\family default
 (and) operator or the 
\family typewriter
|
\family default
 (or) operator and you may explicitly use other logicals.
 For example a factor column 
\family typewriter
type
\family default
 might be used to select rows where type is either one or two via the following:
 
\family typewriter
type==1 | type==2
\family default
.
 
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# select students with Final grades above 90 and
\end_layout

\begin_layout Plain Layout

# average score also above 90
\end_layout

\begin_layout Plain Layout

grades %>% filter(Final > 90, average > 90)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# we could also use an "and" condition
\end_layout

\begin_layout Plain Layout

grades %>% filter(Final > 90 & average > 90)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
slice()
\end_layout

\begin_layout Standard
When you want to filter rows based on row number, this is called slicing.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# grab the first 2 rows
\end_layout

\begin_layout Plain Layout

grades %>% slice(1:2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
arrange()
\end_layout

\begin_layout Standard
We often need to re-order the rows of a data frame.
 For example, we might wish to take our grade book and sort the rows by
 the average score, or perhaps alphabetically.
 The 
\family typewriter
arrange()
\family default
 function does exactly that.
 The first argument is the data frame to re-order, and the subsequent arguments
 are the columns to sort on.
 The order of the sorting column determines the precedent...
 the first sorting column is first used and the second sorting column is
 only used to break ties.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grades %>% arrange(l.name)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

The default sorting is in ascending order, so to sort the grades with the
 highest scoring person in the first row, we must tell 
\family typewriter
arrange
\family default
 to do it in descending order using 
\family typewriter
desc(column.name)
\family default
.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grades %>% arrange(desc(Final))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In a more complicated example, consider the following data and we want to
 order it first by Treatment Level and secondarily by the y-value.
 I want the Treatment level in the default ascending order (Low, Medium,
 High), but the y variable in descending order.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# make some data
\end_layout

\begin_layout Plain Layout

dd <- data.frame(
\end_layout

\begin_layout Plain Layout

  Trt = factor(c("High", "Med", "High", "Low"),        
\end_layout

\begin_layout Plain Layout

               levels = c("Low", "Med", "High")),
\end_layout

\begin_layout Plain Layout

  y = c(8, 3, 9, 9),      
\end_layout

\begin_layout Plain Layout

  z = c(1, 1, 1, 2)) 
\end_layout

\begin_layout Plain Layout

dd
\end_layout

\begin_layout Plain Layout

# arrange the rows first by treatment, and then by y (y in descending order)
\end_layout

\begin_layout Plain Layout

dd %>% arrange(Trt, desc(y))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
mutate()
\end_layout

\begin_layout Standard
I often need to create a new column that is some function of the old columns.
 This was often cumbersome.
 Consider code to calculate the average grade in my grade book example.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grades$average <- (grades$Exam1 + grades$Exam2 + grades$Final) / 3
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead, we could use the 
\family typewriter
mutate()
\family default
 function and avoid all the 
\family typewriter
grades$
\family default
 nonsense.
\begin_inset Foot
status open

\begin_layout Plain Layout
There is another way to do this.
 The command 
\family typewriter
with(df, expression)
\family default
 will attach the dataframe 
\family typewriter
df
\family default
 to the current environment, then evaluate the expression, and then detach
 the dataframe.
 However, to assign the result back to the data frame, I still end up typing
 the name of the dataframe twice.
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grades %>% mutate( average = (Exam1 + Exam2 + Final)/3 )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

You can do multiple calculations within the same 
\family typewriter
mutate()
\family default
 command, and you can even refer to columns that were created in the same
 
\family typewriter
mutate()
\family default
 command.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grades %>% mutate( average = (Exam1 + Exam2 + Final)/3,
\end_layout

\begin_layout Plain Layout

                   grade = cut(average, c(0,60,70,80,90,100), c('F','D','C','B',
'A')) )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
summarise()
\end_layout

\begin_layout Standard
By itself, this function is quite boring, but will become useful later on.
 Its purpose is to calculate summary statistics using any or all of the
 data columns.
 Notice that we get to chose the name of the new column.
 The way to think about this is that we are collapsing information stored
 in multiple rows into a single row of values.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# calculate the mean of exam 1
\end_layout

\begin_layout Plain Layout

summarise( grades, mean.E1=mean(Exam1))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

We could calculate multiple summary statistics if we like.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# calculate the mean of each of the exams
\end_layout

\begin_layout Plain Layout

grades %>% summarise( mean.E1=mean(Exam1), stddev.E1=sd(Exam2) )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

If we want to apply the same statistic to each column, we use the 
\family typewriter
summarise_each()
\family default
 command.
 We have to be a little careful here because the function you use has to
 work on every column (that isn't part of the grouping structure (see 
\family typewriter
group_by()
\family default
)).
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# calculate the mean and stddev of each column
\end_layout

\begin_layout Plain Layout

grades %>% summarise_each( funs(mean, sd) )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Miscellaneous functions
\end_layout

\begin_layout Standard
There are some more function that are useful but aren't as commonly used.
 For sampling the functions 
\family typewriter
sample_n()
\family default
 and 
\family typewriter
sample_frac() 
\family default
will take a subsample of either 
\family typewriter
n
\family default
 rows or of a fraction of the data set.
 The function 
\family typewriter
n()
\family default
 returns the number of rows in the data set.
 Finally 
\family typewriter
rename()
\family default
 will rename a selected column.
\end_layout

\begin_layout Subsection
Split, apply, combine
\end_layout

\begin_layout Standard
Aside from unifying the syntax behind the common operations, the major strength
 of the 
\family typewriter
dplyr
\family default
 package is the ability to split a data frame into a bunch of sub-dataframes,
 apply a sequence of one or more of the operations we just described, and
 then combine results back together.
 We'll consider data from an experiment from spinning wool into yarn.
 This experiment considered two different types of wool (A or B) and three
 different levels of tension on the thread.
 The response variable is the number of breaks in the resulting yarn.
 For each of the 6 
\family typewriter
wool:tension
\family default
 combinations, there are 9 replicated observations.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

data(warpbreaks)
\end_layout

\begin_layout Plain Layout

str(warpbreaks)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

The first we must do is to create a data frame with additional information
 about how to break the data into sub-dataframes.
 In this case, I want to break the data up into the 6 wool-by-tension combinatio
ns.
 Initially we will just figure out how many rows are in each wool-by-tension
 combination.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# what variable(s) shall we group one
\end_layout

\begin_layout Plain Layout

grouped.warpbreaks <- warpbreaks %>% group_by( wool, tension)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# n() is a function that returns how many rows are in the 
\end_layout

\begin_layout Plain Layout

# currently selected sub-dataframe
\end_layout

\begin_layout Plain Layout

summarise(grouped.warpbreaks, n = n() ) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Using the same 
\family typewriter
summarise
\family default
 function, we could calculate the group mean and standard deviation for
 each wool-by-tension group.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

warpbreaks %>% group_by(wool, tension) %>%
\end_layout

\begin_layout Plain Layout

  summarise( n           = n(),             # I added some formatting to
 tell the
\end_layout

\begin_layout Plain Layout

             mean.breaks = mean(breaks),    # reader I am calculating several
\end_layout

\begin_layout Plain Layout

             sd.breaks   = sd(breaks)       # statistics.
\end_layout

\begin_layout Plain Layout

) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If instead of summarizing each split, we might want to just do some calculation
 and the output should have the same number of rows as the input data frame.
 In this case I'll tell 
\family typewriter
dplyr
\family default
 that we are 
\emph on
mutating 
\emph default
the data frame instead of summarizing it.
 For example, suppose that I want to calculate the residual value 
\begin_inset Formula 
\[
e_{ijk}=y_{ijk}-\bar{y}_{ij\cdot}
\]

\end_inset

 where 
\begin_inset Formula $\bar{y}_{ij\cdot}$
\end_inset

 is the mean of each 
\family typewriter
wool:tension
\family default
 combination.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

temp <- warpbreaks %>% 
\end_layout

\begin_layout Plain Layout

   group_by(wool, tension) %>%
\end_layout

\begin_layout Plain Layout

   mutate(resid = breaks - mean(breaks))
\end_layout

\begin_layout Plain Layout

head( temp )  # show the first couple of rows of the result
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Chaining commands together 
\end_layout

\begin_layout Standard
Suppose we have the results of a small 5K race.
 The data given to us is in the order that the runners signed up but we
 want to calculate the results for each gender, calculate the placings,
 and the sort the data frame by gender and then place.
 We can think of this process as having three steps: 1) Splitting 2) Ranking
 3) Re-arranging.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# input the initial data
\end_layout

\begin_layout Plain Layout

race.results <- data.frame(
\end_layout

\begin_layout Plain Layout

  name=c('Bob', 'Jeff', 'Rachel', 'Bonnie', 'Derek', 'April','Elise','David'),
\end_layout

\begin_layout Plain Layout

  time=c(21.23, 19.51, 19.82, 23.45, 20.23, 24.22, 28.83, 15.73),
\end_layout

\begin_layout Plain Layout

  gender=c('M','M','F','F','M','F','F','M')
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# how should I group?
\end_layout

\begin_layout Plain Layout

grouped.results <- race.results %>% group_by( gender)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# calculate the rankings using the rank() function
\end_layout

\begin_layout Plain Layout

temp.df1 <- grouped.results %>% mutate( place = rank(time) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# arrange the rows based on gender and then place
\end_layout

\begin_layout Plain Layout

temp.df2 <- temp.df1 %>% arrange( gender, place )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# output the result
\end_layout

\begin_layout Plain Layout

temp.df2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It would be nice if I didn't have to save all these intermediate results
 because keeping track of 
\family typewriter
temp1
\family default
 and 
\family typewriter
temp2
\family default
 gets pretty annoying if I keep changing the order of how things or calculated
 or add/subtract steps.
 The way this is typically handled in R is to to just nest one command inside
 the next.
 The same set of commands could be run as follows:
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

arrange( 
\end_layout

\begin_layout Plain Layout

  mutate(
\end_layout

\begin_layout Plain Layout

    group_by( 
\end_layout

\begin_layout Plain Layout

      race.results,         # using race.results
\end_layout

\begin_layout Plain Layout

      gender),              # group by gender     
\end_layout

\begin_layout Plain Layout

    place = rank( time )),  # mutate to calculate the place column
\end_layout

\begin_layout Plain Layout

  gender, place)            # arrange the result by gender and place
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

This is extremely hard to read because the commands are separated from the
 arguments (e.g.
 the 
\family typewriter
arrange
\family default
 function call was at the top, but the columns to arrange by are on the
 last line).
 To get around this, the author of 
\family typewriter
dplyr
\family default
 gives us an operator to combine these simple operations smoothly.
 The composition operation 
\family typewriter
%>%
\family default
 takes the following 
\family typewriter
A %>% f(B)
\family default
 and converts it to the statement 
\family typewriter
f(A, B)
\family default
.
 This allows us to write the following code that does exactly what the above
 two code chunks did.
 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

race.results %>%                   # what data frame am I interested in
\end_layout

\begin_layout Plain Layout

  group_by(gender) %>%             # break things by gender
\end_layout

\begin_layout Plain Layout

  mutate(place=rank(time)) %>%     # calculate the placings within each
 gender
\end_layout

\begin_layout Plain Layout

  arrange(gender, place)           # arrange the result by gender and place
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

If I only wanted the top three finishers in each gender, we could simply
 add a 
\family typewriter
filter
\family default
 command after the 
\family typewriter
place
\family default
 column was calculated.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

race.results %>%                   # what data frame am I interested in
\end_layout

\begin_layout Plain Layout

  group_by(gender) %>%             # break things by gender
\end_layout

\begin_layout Plain Layout

  mutate(place=rank(time)) %>%     # calculate the placings within each
 gender
\end_layout

\begin_layout Plain Layout

  filter( place <= 3 ) %>%         # only get the top 3 finishers within
 each gender
\end_layout

\begin_layout Plain Layout

  arrange(gender, place)           # arrange the result by gender and place
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Exercises
\end_layout

\begin_layout Enumerate
The dataset 
\family typewriter
ChickWeight
\family default
 which tracks the weights of 48 baby chickens (chicks) feed four different
 diets.
\end_layout

\begin_deeper
\begin_layout Enumerate
Load the dataset using 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

data(ChickWeight)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Look at the help files for the description of the columns.
\end_layout

\begin_layout Enumerate
Remove all the observations except for the weights on day 10 and day 20.
\end_layout

\begin_layout Enumerate
Calculate the mean and standard deviation for each diet group on days 10
 and 20.
\end_layout

\end_deeper
\begin_layout Enumerate
The 
\emph on
OpenIntro
\emph default
 textbook on statistics includes a data set on body dimensions.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Load the file using 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

Body <- read.csv('http://www.openintro.org/stat/data/bdims.csv')
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
The column 
\family typewriter
sex
\family default
 is coded as a 
\family typewriter
1
\family default
 if the individual is male and 
\family typewriter
0
\family default
 if female.
 This is a non-intuitive labeling system.
 Create a new column 
\family typewriter
sex.MF
\family default
 that uses labels 
\family typewriter
Male
\family default
 and 
\family typewriter
Female
\family default
.

\family typewriter
 
\end_layout

\begin_layout Enumerate
The columns 
\family typewriter
wgt
\family default
 and 
\family typewriter
hgt
\family default
 measure weight and height in kilograms and centimeters (respectively).
 Use these to calculate the Body Mass Index (BMI) for each individual where
 
\begin_inset Formula 
\[
BMI=\frac{Weight\,(kg)}{\left[Height\,(m)\right]^{2}}
\]

\end_inset

Notice you should get values between 18 to 30.
 
\end_layout

\begin_layout Enumerate
Double check that your calculated BMI column is correct by examining the
 summary statistics of the column.
\end_layout

\begin_layout Enumerate
The function 
\family typewriter
cut
\family default
 takes a vector of continuous numerical data and creates a factor based
 on your give cut-points.
 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# Define a continuous vector to convert to a factor
\end_layout

\begin_layout Plain Layout

x <- 1:10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# divide range of x into three groups of equal length
\end_layout

\begin_layout Plain Layout

cut(x, breaks=3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# divide x into four groups, where I specify all 5 break points
\end_layout

\begin_layout Plain Layout

cut(x, breaks = c(0, 2.5, 5.0, 7.5, 10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# divide x into 3 groups, but give them a nicer
\end_layout

\begin_layout Plain Layout

# set of group names
\end_layout

\begin_layout Plain Layout

cut(x, breaks=3, labels=c('Low','Medium','High'))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Create a new column of in the data frame that divides the 
\family typewriter
age
\family default
 into decades (10-19, 20-29, 30-39, etc).
 Notice the oldest person in the study is 67.
\end_layout

\begin_layout Enumerate
Find the average BMI for each Sex and Age group.
\end_layout

\end_deeper
\end_body
\end_document
