[
["9-data-reshaping.html", "Chapter 9 Data Reshaping 9.1 tidyr 9.2 Table Joins 9.3 Exercises", " Chapter 9 Data Reshaping library(tidyr) # for the gather/spread commands library(dplyr) # for the join stuff Most of the time, our data is in the form of a data frame and we are interested in exploring the relationships. However most procedures in R expect the data to show up in a ‘long’ format where each row is an observation and each column is a covariate. In practice, the data is often not stored like that and the data comes to us with repeated observations included on a single row. This is often done as a memory saving technique or because there is some structure in the data that makes the ‘wide’ format attractive. As a result, we need a way to convert data from ‘wide’ to ‘long’ and vice-versa. 9.1 tidyr There is a common issue with obtaining data with many columns that you wish were organized as rows. For example, I might have data in a grade book that has several homework scores and I’d like to produce a nice graph that has assignment number on the x-axis and score on the y-axis. Unfortunately this is incredibly hard to do when the data is arranged in the following way: grade.book &lt;- rbind( data.frame(name=&#39;Alison&#39;, HW.1=8, HW.2=5, HW.3=8), data.frame(name=&#39;Brandon&#39;, HW.1=5, HW.2=3, HW.3=6), data.frame(name=&#39;Charles&#39;, HW.1=9, HW.2=7, HW.3=9)) grade.book ## name HW.1 HW.2 HW.3 ## 1 Alison 8 5 8 ## 2 Brandon 5 3 6 ## 3 Charles 9 7 9 What we want to do is turn this data frame from a wide data frame into a long data frame. In MS Excel this is called pivoting. Essentially I’d like to create a data frame with three columns: name, assignment, and score. That is to say that each homework datum really has three pieces of information: who it came from, which homework it was, and what the score was. It doesn’t conceptually matter if I store it as 3 columns or 3 rows so long as there is a way to identify how a student scored on a particular homework. So we want to reshape the HW1 to HW3 columns into two columns (assignment and score). This package was built by the sample people that created dplyr and ggplot2 and there is a nice introduction at: [http://blog.rstudio.org/2014/07/22/introducing-tidyr/] 9.1.1 Verbs As with the dplyr package, there are two main verbs to remember: gather - Gather multiple columns that are related into two columns that contain the original column name and the value. For example for columns HW1, HW2, HW3 we would gather them into two column HomeworkNumber and Score. In this case, we refer to HomeworkNumber as the key column and Score as the value column. So for any key:value pair you know everything you need. spread - This is the opposite of gather. This takes a key column (or columns) and a results column and forms a new column for each level of the key column(s). # first we gather the score columns into columns we&#39;ll name Assesment and Score tidy.scores &lt;- grade.book %&gt;% gather( key=Assessement, # What should I call the key column value=Score, # What should I call the values column HW.1:HW.3 # which columns to apply this to ) tidy.scores ## name Assessement Score ## 1 Alison HW.1 8 ## 2 Brandon HW.1 5 ## 3 Charles HW.1 9 ## 4 Alison HW.2 5 ## 5 Brandon HW.2 3 ## 6 Charles HW.2 7 ## 7 Alison HW.3 8 ## 8 Brandon HW.3 6 ## 9 Charles HW.3 9 To spread the key:value pairs out into a matrix, we use the spread() command. # score columns into columns we&#39;ll name Assesment and Score tidy.scores %&gt;% spread( key=Assessement, value=Score ) ## name HW.1 HW.2 HW.3 ## 1 Alison 8 5 8 ## 2 Brandon 5 3 6 ## 3 Charles 9 7 9 One way to keep straight which is the key column is that the key is the category, while value is the numerical value or response. 9.2 Table Joins Often we need to squish together two data frames but they do not have the same number of rows. Consider the case where we have a data frame of observations of fish (say 200 fish caught per lake) and a separate data frame that contains information about lake (perhaps surface area, max depth, pH, etc). I want to store them as two separate tables so that when I have to record a lake level observation, I only input it one place. This decreases the chance that I make a copy/paste error. To illustrate the different types of table joins, we’ll consider two different tables. Fish.Data &lt;- tibble(Lake = c(&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;C&#39;,&#39;C&#39;), Fish.Weight=101:106) Lake.Data &lt;- tibble(Lake = c( &#39;B&#39;,&#39;C&#39;,&#39;D&#39;), pH=c(6.5, 6.3, 6.1)) Fish.Data ## # A tibble: 6 x 2 ## Lake Fish.Weight ## &lt;chr&gt; &lt;int&gt; ## 1 A 101 ## 2 A 102 ## 3 B 103 ## 4 B 104 ## 5 C 105 ## 6 C 106 Lake.Data ## # A tibble: 3 x 2 ## Lake pH ## &lt;chr&gt; &lt;dbl&gt; ## 1 B 6.5 ## 2 C 6.3 ## 3 D 6.1 Notice that each of these tables has a column labled Lake. When we join these two tables, the row that describes Lake A should be duplicated for each row in the Fish.Data that corresponds with fish caught from Lake A. full_join(Fish.Data, Lake.Data) ## Joining, by = &quot;Lake&quot; ## # A tibble: 7 x 3 ## Lake Fish.Weight pH ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 A 101 NA ## 2 A 102 NA ## 3 B 103 6.5 ## 4 B 104 6.5 ## 5 C 105 6.3 ## 6 C 106 6.3 ## 7 D NA 6.1 Notice that because we didn’t have any fish caught in lake D and we don’t have any Lake information about lake A, when we join these two tables, we end up introducing missing observations into the resulting data frame. The other types of joins govern the behavor or these missing data. left_join(A, B) For each row in A, match with a row in B, but don’t create any more rows than what was already in A. inner_join(A,B) Only match row values where both data frames have a value. left_join(Fish.Data, Lake.Data) ## Joining, by = &quot;Lake&quot; ## # A tibble: 6 x 3 ## Lake Fish.Weight pH ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 A 101 NA ## 2 A 102 NA ## 3 B 103 6.5 ## 4 B 104 6.5 ## 5 C 105 6.3 ## 6 C 106 6.3 inner_join(Fish.Data, Lake.Data) ## Joining, by = &quot;Lake&quot; ## # A tibble: 4 x 3 ## Lake Fish.Weight pH ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 B 103 6.5 ## 2 B 104 6.5 ## 3 C 105 6.3 ## 4 C 106 6.3 The above examples assumed that the column used to join the two tables was named the same in both tables. This is good practice to try to do, but sometimes you have to work with data where that isn’t the case. In that situation you can use the by=c(&quot;ColName.A&quot;=&quot;ColName.B&quot;) syntax where ColName.A represents the name of the column in the first data frame and ColName.B is the equivalent column in the second data frame. 9.3 Exercises Suppose we are given information about the maximum daily temperature from a weather station in Flagstaff, AZ. The file is available at the GitHub site that this book is hosted on. FlagTemp &lt;- read.csv( &#39;https://github.com/dereksonderegger/STA_570L_Book/raw/master/data-raw/FlagMaxTemp.csv&#39;, header=TRUE, sep=&#39;,&#39;) This file is in a wide format, where each row represents a month and the columns X1, X2, …, X31 represent the day of the month the observation was made. Convert data set to the long format where the data has only four columns: Year, Month, Day, Tmax. Calculate the average monthly maximum temperature for each Month in the dataset (So there will be 365 mean maximum temperatures). You’ll probably have some issues taking the mean because there are a number of values that are missing and by default R refuses to take means and sums when there is missing data. The argument na.rm=TRUE to mean() allows you to force R to remove the missing observations before calculating the mean. Convert the average month maximums back to a wide data format where each line represents a year and there are 12 columns of temperature data (one for each month) along with a column for the year. There will be a couple of months that still have missing data because the weather station was out of commision for those months and there was NO data for the entire month. A common task is to take a set of data that has multiple categorical variables and create a table of the number of cases for each combination. An introductory statistics textbook contains a dataset summarizing student surveys from several sections of an intro class. The two variables of interest for us are Gender and Year which are the students gender and year in college. Download the dataset and correctly order the Year variable using the following: Survey &lt;- read.csv(&#39;http://www.lock5stat.com/datasets/StudentSurvey.csv&#39;, na.strings=c(&#39;&#39;,&#39; &#39;)) %&gt;% mutate(Year = factor(Year, levels=c(&#39;FirstYear&#39;,&#39;Sophomore&#39;,&#39;Junior&#39;,&#39;Senior&#39;))) Using some combination of dplyr functions, produce a data set with eight rows that contains the number of responses for each gender:year combination. Notice there are two females that neglected to give their Year and you should remove them first. The function is.na(Year) will return logical values indicating if the Year value was missing and you can flip those values using the negation operator !. So you might consider using !is.na(Year) as the argument to a filter() command. Alternatively you sort on Year and remove the first two rows using slice(-2:-1). Next you’ll want to summarize each Year/Gender group using the n() function which gives the number of rows in a data set. Using tidyr commands, produce a table of the number of responses in the following form: Gender First Year Sophmore Junior Senior Female Male The package nycflights contains information about all the flights that arrived in or left from New York City in 2013. This package contains five data tables, but there are three data tables we will work with. The data table flights gives information about a particular flight, airports gives information about a particular airport, and airlines gives information about each airline. Create a table of all the flights on February 14th by Virgin America that has columns for the carrier, destination, departure time, and flight duration. Join this table with the airports information for the destination. Notice that because the column for the destination airport code doesn’t match up between flights and airports, you’ll have to use the by=c(&quot;TableA.Col&quot;=&quot;TableB.Col&quot;) argument where you insert the correct names for TableA.Col and TableB.Col. "]
]
