#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
User Defined Functions
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

opts_chunk$set(cache.path = './cache/Functions/',
\end_layout

\begin_layout Plain Layout

               fig.path   = './figure/Functions/')
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset

It is very important to be able to define a piece of programing logic that
 is repeated often.
 For example, I don't want to have to always program the mathematical code
 for calculating the sample variance of a vector of data.
 Instead I just want to call a function that does everything for me and
 I don't have to worry about the details.
 
\end_layout

\begin_layout Standard
While hiding the computational details is nice, fundamentally writing functions
 allows us to think about our problems at a higher layer of abstraction.
 For example, most scientists just want to run a t-test on their data and
 get the appropriate p-value out; they want to focus on their problem and
 not how to calculate what the appropriate degrees of freedom are.
 Functions let us do that.
 
\end_layout

\begin_layout Section
Basic function definition
\end_layout

\begin_layout Standard
In the course of your analysis, it can be useful to define your own functions.
 The format for defining your own function is 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

function.name <- function(arg1, arg2, arg3)
\end_layout

\begin_layout Plain Layout

  statement 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\family typewriter
arg1
\family default
 is the first argument passed to the function and 
\family typewriter
arg2
\family default
 is the second.
 As usual 
\family typewriter
statement
\family default
 is a single statement or multiple statements wrapped in the familiar curly
 brackets 
\family typewriter
{}
\family default
.
\end_layout

\begin_layout Standard
To illustrate how to define your own function, we will define a variance
 calculating function.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# define my function
\end_layout

\begin_layout Plain Layout

my.var <- function(x){
\end_layout

\begin_layout Plain Layout

  n <- length(x)                # calculate sample size
\end_layout

\begin_layout Plain Layout

  xbar <- mean(x)               # calculate sample mean
\end_layout

\begin_layout Plain Layout

  SSE <- sum( (x-xbar)^2 )      # calculate sum of squared error
\end_layout

\begin_layout Plain Layout

  v <- SSE / ( n - 1 )          # "average" squared error
\end_layout

\begin_layout Plain Layout

  return(v)                     # result of function is v
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# create a vector that I wish to calculate the variance of
\end_layout

\begin_layout Plain Layout

test.vector <- c(1,2,2,4,5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# calculate the variance using my function
\end_layout

\begin_layout Plain Layout

calculated.var <- my.var( test.vector )
\end_layout

\begin_layout Plain Layout

calculated.var
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that even though I defined my function using 
\family typewriter
x
\family default
 as my vector of data, and passed my function something named 
\family typewriter
test.vector
\family default
, R does the appropriate renaming.
\begin_inset Foot
status open

\begin_layout Plain Layout
If my function doesn't modify its input arguments, then R just passes a
 pointer to the inputs to avoid copying large amounts of data when you call
 a function.
 If your function modifies its input, then R will take the input data, copy
 it, and then pass that new copy to the function.
 This means that a function cannot modify its arguments.
 In Computer Science parlance, R does not allow for procedural side effects.
\end_layout

\end_inset

 Think of the variable 
\family typewriter
x
\family default
 as a placeholder, with it being replaced by whatever gets passed into the
 function.
\end_layout

\begin_layout Standard
When I call a function, the function might cause something to happen (e.g.
 draw a plot) or it might do some calculates the result is returned by the
 function and we might want to save that.
 Inside a function, if I want the result of some calculation saved, I return
 the result as the output of the function.
 The way I specify to do this is via the 
\family typewriter
return
\family default
 statement.
\begin_inset Foot
status open

\begin_layout Plain Layout
Actually R doesn't completely require this.
 But the alternative method is less intuitive and I strongly recommend using
 the 
\family typewriter
return()
\family default
 statement for readability.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By writing a function, I can use the same chunk of code repeatedly.
 This means that I can do all my tedious calculations inside the function
 and just call the function whenever I want and happily ignore the details.
 Consider the function 
\family typewriter
t.test()
\family default
 which we have used to do all the calculations in a t-test.
 We could write a similar function using the following code:
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# define my function
\end_layout

\begin_layout Plain Layout

one.sample.t.test <- function(input.data, mu0){
\end_layout

\begin_layout Plain Layout

  n    <- length(input.data)
\end_layout

\begin_layout Plain Layout

  xbar <- mean(input.data)
\end_layout

\begin_layout Plain Layout

  s    <- sd(input.data)
\end_layout

\begin_layout Plain Layout

  t    <- (xbar - mu0)/(s / sqrt(n))
\end_layout

\begin_layout Plain Layout

  if( t < 0 ){
\end_layout

\begin_layout Plain Layout

    p.value <- 2 * pt(t, df=n-1)
\end_layout

\begin_layout Plain Layout

  }else{
\end_layout

\begin_layout Plain Layout

    p.value <- 2 * (1-pt(t, df=n-1))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  # we haven't addressed how to print things in a organized 
\end_layout

\begin_layout Plain Layout

  # fashion, the following is ugly, but works...
\end_layout

\begin_layout Plain Layout

  # Notice that this function returns a character string
\end_layout

\begin_layout Plain Layout

  # with the necessary information in the strong.
\end_layout

\begin_layout Plain Layout

  return( paste('t =', t, ' and p.value =', p.value) )
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# create a vector that I wish apply a one-sample t-test on.
\end_layout

\begin_layout Plain Layout

test.data <- c(1,2,2,4,5,4,3,2,3,2,4,5,6)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# calculate the variance using my function
\end_layout

\begin_layout Plain Layout

one.sample.t.test( test.data, 2 )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nearly every function we use to do data analysis is written in a similar
 fashion.
 Somebody decided it would be convenient to have a function that did an
 ANOVA analysis and they wrote something similar to the above function,
 but is a bit grander in scope.
 Even if you don't end up writing any of your own functions, knowing how
 to will help you understand why certain functions you use are designed
 the way they are.
 
\end_layout

\begin_layout Section
Parameter Defaults
\end_layout

\begin_layout Standard
When I define a function and can let it take as many arguments as I want
 and I can also give default values to the arguments.
 For example we can define the normal density function using the following
 code which gives a default mean of 
\begin_inset Formula $0$
\end_inset

 and default standard deviation of 
\begin_inset Formula $1$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# a function that defines the shape of a normal distribution.
\end_layout

\begin_layout Plain Layout

# by including mu=0, we give a default value that the function
\end_layout

\begin_layout Plain Layout

# user can override
\end_layout

\begin_layout Plain Layout

dnorm.alternate <- function(x, mu=0, sd=1){
\end_layout

\begin_layout Plain Layout

  out <- 1 / (sd * sqrt(2*pi)) * exp( -(x-mu)^2 / (2 * sd^2) )
\end_layout

\begin_layout Plain Layout

  return(out)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# test the function to see if it works
\end_layout

\begin_layout Plain Layout

dnorm.alternate(1)
\end_layout

\begin_layout Plain Layout

dnorm.alternate(1, mu=1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fig.height=3, fig.width=5>>=
\end_layout

\begin_layout Plain Layout

# Lets test the function a bit more by drawing the height
\end_layout

\begin_layout Plain Layout

# of the normal distribution a lots of different points
\end_layout

\begin_layout Plain Layout

# ...
 First the standard normal!
\end_layout

\begin_layout Plain Layout

x <- seq(-3, 3, length=601)
\end_layout

\begin_layout Plain Layout

plot( x, dnorm.alternate(x) )  # use default mu=0, sd=1
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fig.height=3, fig.width=5>>=
\end_layout

\begin_layout Plain Layout

# next a normal with mean 1, and standard deviation 1
\end_layout

\begin_layout Plain Layout

plot( x, dnorm.alternate(x, mu=1) ) # override mu, but use sd=1
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many functions that we use have defaults that we don't normally mess with.
 For example, the function 
\family typewriter
mean()
\family default
 has an option the specifies what it should do if your vector of data has
 missing data.
 The common solution is to remove those observations, but we might have
 wanted to say that the mean is unknown one component of it was unknown.
 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c(1,2,3,NA)   # fourth element is missing
\end_layout

\begin_layout Plain Layout

mean(x)            # default is to return NA if any element is missing
\end_layout

\begin_layout Plain Layout

mean(x, na.rm=TRUE) # Only average the non-missing data
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you look at the help pages for different functions, you'll see in the
 function definitions what the default values are.
 For example, the function 
\family typewriter
mean
\family default
 has another option, 
\family typewriter
trim
\family default
, which specifies what percent of the data to trim at the extremes.
 Because we would expect 
\family typewriter
mean
\family default
 to not do any trimming by default, the authors have appropriately defined
 the default amount of trimming to be zero via the definition 
\family typewriter
trim=0
\family default
.
\end_layout

\begin_layout Section
Ellipses
\end_layout

\begin_layout Standard
When writing functions, I occasionally have a situation where I call function
 
\family typewriter
a()
\family default
 and function 
\family typewriter
a()
\family default
 needs to call another function, say 
\family typewriter
b()
\family default
, and I want to pass an unusual parameter to that function.
 To do this, I'll use a set of three periods called an 
\emph on
ellipses.

\emph default
 What these do is represent a set of parameter values that will be passed
 along to a subsequent function.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

For example the following code takes the result of a simple linear regression
 and plots the data and the regression line and confidence region (
\emph on
basically I'm recreating a function that does the same thing as 
\family typewriter
ggplot2's
\family default
 geom_smooth() layer).
 
\emph default
I might not want to specify (and give good defaults) to every single
\emph on
 
\emph default
graphical parameter that the 
\family typewriter
plot()
\family default
 function supports.
 Instead I'll just use the 
\family typewriter
'...'
\family default
 argument and pass any additional parameters to the plot function.
\emph on

\begin_inset Newline newline
\end_inset


\emph default

\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# a function that draws the regression line and confidence interval
\end_layout

\begin_layout Plain Layout

# notice it doesn't return anything...
 all it does is draw a plot
\end_layout

\begin_layout Plain Layout

show.lm <- function(m, interval.type='confidence', fill.col='light grey', ...){
\end_layout

\begin_layout Plain Layout

  x <- m$model[,2]       # extract the predictor variable
\end_layout

\begin_layout Plain Layout

  y <- m$model[,1]       # extract the response
\end_layout

\begin_layout Plain Layout

  pred <- predict(m, interval=interval.type)
\end_layout

\begin_layout Plain Layout

  plot(x, y, ...)
\end_layout

\begin_layout Plain Layout

  polygon( c(x,rev(x)),                         # draw the ribbon defined
\end_layout

\begin_layout Plain Layout

           c(pred[,'lwr'], rev(pred[,'upr'])),  # by lwr and upr - polygon
\end_layout

\begin_layout Plain Layout

           col='light grey')                    # fills in the region defined
 by            
\end_layout

\begin_layout Plain Layout

  lines(x, pred[, 'fit'])                       # a set of vertices, need
 to reverse            
\end_layout

\begin_layout Plain Layout

  points(x, y)                                 # the uppers to make a nice
 figure
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

This function looks daunting, but we experiment to see what it does.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# first define a simple linear model from our cherry tree data
\end_layout

\begin_layout Plain Layout

m <- lm( Volume ~ Girth, data=trees )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fig.height=3, fig.width=5>>=
\end_layout

\begin_layout Plain Layout

# call the function with no extraneous parameters
\end_layout

\begin_layout Plain Layout

show.lm( m )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fig.height=3, fig.width=5>>=
\end_layout

\begin_layout Plain Layout

# Pass arguments that will just be passed along to the plot function
\end_layout

\begin_layout Plain Layout

show.lm( m, xlab='Girth', ylab='Volume', 
\end_layout

\begin_layout Plain Layout

         main='Relationship between Girth and Volume')
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

This type of trick is done commonly.
 Look at the help files for 
\family typewriter
hist()
\family default
 and 
\family typewriter
qqnorm()
\family default
 and you'll see the ellipses used to pass graphical parameters along to
 sub-functions.
 Functions like 
\family typewriter
lm()
\family default
 use the ellipses to pass arguments to the low level regression fitting
 functions that do the actual calculations.
 By only including these parameters via the ellipses, must users won't be
 tempted to mess with the parameters, but experts who know the nitty-gritty
 details can still modify those parameters.
 
\end_layout

\begin_layout Section
Function Overloading
\end_layout

\begin_layout Standard
Frequently the user wants to inspect the results of some calculation and
 display a variable or object to the screen.
 The 
\family typewriter
print()
\family default
 function does exactly that, but it acts differently for matrices than it
 does for vectors.
 It especially acts different for lists that I obtained from a call like
 
\family typewriter
lm()
\family default
 or 
\family typewriter
aov()
\family default
.
 
\end_layout

\begin_layout Standard
The reason that the print function can act differently depending on the
 object type that I pass it is because the function 
\family typewriter
print()
\family default
 is 
\emph on
overloaded.

\emph default
 What this means is that there is a 
\family typewriter
print.lm()
\family default
 function that is called whenever I call 
\family typewriter
print(obj)
\family default
 when 
\family typewriter
obj
\family default
 is the output of an 
\family typewriter
lm()
\family default
 command.
\end_layout

\begin_layout Standard
Recall that we initially introduced a few different classes of data, Numerical,
 Factors, and Logicals.
 It turns out that I can create more types of classes.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fig.keep='none'>>=
\end_layout

\begin_layout Plain Layout

x <- seq(1:10)
\end_layout

\begin_layout Plain Layout

y <- 3+2*x+rnorm(10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

h <- hist(y)  # h should be of class "Histogram"
\end_layout

\begin_layout Plain Layout

class(h)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

model <- lm( y ~ x ) # model is something of class "lm"
\end_layout

\begin_layout Plain Layout

class(model)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many common functions such as 
\family typewriter
plot()
\family default
 are overloaded so that when I call the plot function with an object, it
 will in turn call 
\family typewriter
plot.lm()
\family default
 or 
\family typewriter
plot.histogram()
\family default
 as appropriate.
 When building statistical models I am often interested in different quantities
 and would like to get those regardless of the model I am using.
 Below are a list of functions that work whether I fit a model via 
\family typewriter
aov()
\family default
, 
\family typewriter
lm()
\family default
, 
\family typewriter
glm()
\family default
, or 
\family typewriter
gam()
\family default
.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quantity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Residuals
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
resid( obj )
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Model Coefficients
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
coef( obj )
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Summary Table
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
summary( obj )
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ANOVA table
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
anova( obj )
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AIC value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
AIC( obj )
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

For the residual function, there actually exists a 
\family typewriter
resid.aov()
\family default
 function, and 
\family typewriter
resid.lm()
\family default
, 
\family typewriter
resid.glm()
\family default
, and 
\family typewriter
resid.gam()
\family default
 and it is these functions are called when we run the command 
\family typewriter
resid( obj )
\family default
.
 
\end_layout

\begin_layout Section
Scope
\end_layout

\begin_layout Standard
Consider the case where we make a function that calculates the trimmed mean.
 A good implementation of the function is given here.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

trimmed.mean <- function(x, k){
\end_layout

\begin_layout Plain Layout

  x <- sort(x)
\end_layout

\begin_layout Plain Layout

  n <- length(x)
\end_layout

\begin_layout Plain Layout

  if( k > 0){
\end_layout

\begin_layout Plain Layout

    x <- x[c(-1*(1:k), -1*((n-k+1):n))]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  tm <- sum(x)/ length(x)
\end_layout

\begin_layout Plain Layout

  return( tm )
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

x <- c(10:1,50)                        # 10, 9, 8, ..., 1
\end_layout

\begin_layout Plain Layout

output <- trimmed.mean(x, k=2)
\end_layout

\begin_layout Plain Layout

output
\end_layout

\begin_layout Plain Layout

x                                # x is unchanged
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that even though I passed 
\family typewriter
x
\family default
 into the function and then sorted it, 
\family typewriter
x
\family default
 remained unsorted outside the function.
\begin_inset Foot
status open

\begin_layout Plain Layout
When I modified 
\family typewriter
x
\family default
, R made a copy of 
\family typewriter
x
\family default
 and sorted the copy that belonged to the function so that I didn't modify
 a variable that was defined outside of the scope of my function.
 The only way you can do that is to use the assignment operator ' 
\family typewriter
<<-
\family default
 '.
 This can lead to all sorts of weird behavior and I recommend against it.
\end_layout

\end_inset

 But what if I didn't bother with passing 
\family typewriter
x
\family default
 and 
\family typewriter
k
\family default
.
 If I don't pass in the values of 
\family typewriter
x
\family default
 and 
\family typewriter
k
\family default
, then R will try to find them in my current workspace.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

trimmed.mean <- function(){
\end_layout

\begin_layout Plain Layout

  x <- sort(x)
\end_layout

\begin_layout Plain Layout

  n <- length(x)
\end_layout

\begin_layout Plain Layout

  if( k > 0){
\end_layout

\begin_layout Plain Layout

    x <- x[c(-1*(1:k), -1*((n-k+1):n))]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  tm <- sum(x)/length(x)
\end_layout

\begin_layout Plain Layout

  return( tm )
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

x <- c( 1:10, 50 )
\end_layout

\begin_layout Plain Layout

k <- 2
\end_layout

\begin_layout Plain Layout

output <- trimmed.mean()  # amazingly this still works
\end_layout

\begin_layout Plain Layout

output                    # this is actually the correct output!
\end_layout

\begin_layout Plain Layout

x                         # still the same x vector
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
So if I forget to pass some variable into a function, but it happens to
 be defined outside the function, R will find it.
 It is not good practice to rely on that because how do I take the trimmed
 mean of a vector named 
\family typewriter
z
\family default
? Worse yet, what if the variable 
\family typewriter
x
\family default
 changes between runs of your function? What should be consistently giving
 the same result keeps changing.
 This is especially insidious when you have defined most of the arguments
 the function uses, but missed one.
 Your function happily goes to the next higher scope and sometimes finds
 it.
 
\end_layout

\begin_layout Standard
When executing a function, R will have access to all the variables defined
 in the function, all the variables defined in the function that called
 your function and so on until the base workspace.
 However, you should never let your function refer to something that is
 not either created in your function or passed in via a parameter.
\end_layout

\begin_layout Section
Exercises
\end_layout

\begin_layout Enumerate
The following function augments the 
\family typewriter
t.test()
\family default
 so that it calculates the usual t test information along with the bootstrap
 confidence interval.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x.t.test <- function( formula, data, conf.level=0.95, M=10000, ...
 ){
\end_layout

\begin_layout Plain Layout

  alpha <- 1-conf.level
\end_layout

\begin_layout Plain Layout

  SampDist <- rep(NA, M)
\end_layout

\begin_layout Plain Layout

  for( i in 1:M ){
\end_layout

\begin_layout Plain Layout

    SampDist[i] <- t.test(formula, data)$statistic
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  bootCI <- quantile(SampDist, probs=c(alpha/2, 1-alpha/2))  # vector of
 2 numbers
\end_layout

\begin_layout Plain Layout

  bootCI <- paste( bootCI, collapse=TRUE )                   # Character
 string
\end_layout

\begin_layout Plain Layout

  t.test(formula, data, mu, conf.level, ...
 )
\end_layout

\begin_layout Plain Layout

  print(paste('Bootstrap Confidence Interval:', bootCI))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Write a function that calculates the density function of a 
\emph on
Uniform
\emph default
 continuous variable on the interval 
\begin_inset Formula $\left(a,b\right)$
\end_inset

.
 The function is defined as
\begin_inset Formula 
\[
f\left(x\right)=\begin{cases}
\frac{1}{b-a} & \;\;\;\textrm{if }a\le x\le b\\
0 & \;\;\;\textrm{otherwise}
\end{cases}
\]

\end_inset

which looks like this
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=FALSE, message=FALSE, fig.height=2, fig.width=6>>=
\end_layout

\begin_layout Plain Layout

library(ggplot2) 
\end_layout

\begin_layout Plain Layout

library(dplyr) 
\end_layout

\begin_layout Plain Layout

data <- data.frame(x = seq(-.25,1.25, length=301)) 
\end_layout

\begin_layout Plain Layout

data <- data %>% mutate( y = dunif(x,0,1) ) 
\end_layout

\begin_layout Plain Layout

ggplot(data, aes(x=x, y=y)) +
\end_layout

\begin_layout Plain Layout

  geom_line() +
\end_layout

\begin_layout Plain Layout

  scale_x_continuous( breaks=c(0,1), labels=c('a','b') ) +
\end_layout

\begin_layout Plain Layout

  scale_y_continuous( breaks=c(0,1), labels=c(0,expression(1 / (a+b) ))
 ) +
\end_layout

\begin_layout Plain Layout

  labs(y='density') + theme_bw()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

We want to write a function 
\family typewriter
duniform(x, a, b)
\family default
 that takes an arbitrary value of x and parameters 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 and return the appropriate height of the density function.
 For various values of 
\family typewriter
x
\family default
, 
\family typewriter
a
\family default
, and 
\family typewriter
b
\family default
, demonstrate that your function returns the correct density value.
 Ideally, your function should be able to take a vector of values for 
\family typewriter
x
\family default
 and return a vector of densities.
\end_layout

\begin_layout Enumerate
I very often want to provide default values to a parameter that I pass to
 a function.
 For example, it is so common for me to use the 
\family typewriter
pnorm()
\family default
 and 
\family typewriter
qnorm()
\family default
 functions on the standard normal, that R will automatically use 
\family typewriter
mean=0
\family default
 and 
\family typewriter
sd=1
\family default
 parameters unless you tell R otherwise.
 To get that behavior, we just set the default parameter values in the definitio
n.
 When the function is called, the user specified value is used, but if none
 is specified, the defaults are used.
 Look at the help page for the functions 
\family typewriter
dunif()
\family default
, and notice that there are a number of default parameters.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

For your 
\family typewriter
duniform()
\family default
 function provide default values of 0 and 1 for 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
.
 Demonstrate that your function is appropriately using the given default
 values.
 
\begin_inset Newline newline
\end_inset


\end_layout

\end_body
\end_document
