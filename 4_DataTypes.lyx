#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Data Types - Numerical, Strings, Factors, and Logicals
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

opts_chunk$set(cache.path = './cache/DataTypes/',
\end_layout

\begin_layout Plain Layout

               fig.path   = './figure/DataTypes/')
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset

There are some basic data types that are commonly used.
 
\end_layout

\begin_layout Enumerate
Integers - These are the integer numbers 
\begin_inset Formula $\left(\dots,-2,-1,0,1,2,\dots\right)$
\end_inset

.
 To convert a numeric value to an integer you may use the function 
\family typewriter
as.integer()
\family default
.
\end_layout

\begin_layout Enumerate
Numeric - These could be any number (whole number or decimal).
 To convert another type to numeric you may use the function 
\family typewriter
as.numeric()
\family default
.
\end_layout

\begin_layout Enumerate
Strings - These are a collection of characters (example: Storing a student's
 last name).
 To convert another type to a string, use 
\family typewriter
as.character()
\family default
.
\end_layout

\begin_layout Enumerate
Factors - These are strings that can only values from a finite set.
 For example we might wish to store a variable that records home department
 of a student.
 Since the department can only come from a finite set of possibilities,
 I would use a factor.
 Factors are categorical variables, but R calls them factors instead of
 categorical variable.
 A vector of values of another type can always be converted to a factor
 using the 
\family typewriter
as.factor()
\family default
 command.
\end_layout

\begin_layout Enumerate
Logicals - This is a special case of a factor that can only take on the
 values 
\family typewriter
TRUE
\family default
 and 
\family typewriter
FALSE
\family default
.
 (Be careful to always capitalize 
\family typewriter
TRUE
\family default
 and 
\family typewriter
FALSE
\family default
.
 Because R is case-sensitive, 
\family typewriter
TRUE
\family default
 is not the same as true.
 Using the function 
\family typewriter
as.logical()
\family default
 you can convert numeric values to 
\family typewriter
TRUE
\family default
 and 
\family typewriter
FALSE
\family default
 where 0 is 
\family typewriter
FALSE
\family default
 and anything else is 
\family typewriter
TRUE
\family default
.
\end_layout

\begin_layout Standard
Depending on the command, R will coerce your data if necessary, but it is
 a good habit to do the coercion yourself.
 If a variable is a number, R will automatically assume that it is continuous
 numerical variable.
 If it is a character string, then R will assume it is a factor when doing
 any statistical analysis.
 
\end_layout

\begin_layout Standard
To find the type of an object, the 
\family typewriter
str()
\family default
 command gives the type, and if the type is complicated, it describes the
 structure of the object.
\end_layout

\begin_layout Section
Integers and Numerics
\end_layout

\begin_layout Standard
Integers and numerics are exactly what they sound like.
 Integers can take on whole number values, while numerics can take on any
 decimal value.
 The reason that there are two separate data types is that integers require
 less memory to store than numerics.
 For most users, the distinction can be ignored.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c(1,2,1,2,1)
\end_layout

\begin_layout Plain Layout

# show that x is of type 'numeric'
\end_layout

\begin_layout Plain Layout

str(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Character Strings
\end_layout

\begin_layout Standard
In R, we can think of collections of letters and numbers as a single entity
 called a string.
 Other programming languages think of strings as vectors of letters, but
 R does not so you can't just pull off the first character using vector
 tricks.
 In practice, there are no limits as to how long string can be.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- "Goodnight Moon"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Notice x is of type character (chr)
\end_layout

\begin_layout Plain Layout

str(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# R doesn't care if I use single quotes or double quotes, but don't mix
 them...
\end_layout

\begin_layout Plain Layout

y <- 'Hop on Pop!'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# we can make a vector of character strings
\end_layout

\begin_layout Plain Layout

Books <- c(x, y, 'Where the Wild Things Are')
\end_layout

\begin_layout Plain Layout

Books
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Character strings can also contain numbers and if the character string is
 in the correct format for a number, we can convert it to a number.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- '5.2'
\end_layout

\begin_layout Plain Layout

str(x)     # x really is a character string
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

as.numeric(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we try an operation that only makes sense on numeric types (like addition)
 then R complain unless we first convert it
\begin_inset Foot
status open

\begin_layout Plain Layout
There are places where R will try to coerce an object to another data type
 but it happens inconsistently and you should just do the conversion yourself.
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x+1
\end_layout

\begin_layout Plain Layout

as.numeric(x) + 1
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Factors
\end_layout

\begin_layout Standard
Factors are how R keeps track of categorical variables.
 R does this in a two step pattern.
 First it figures out how many categories there are and remembers which
 category an observation belongs two and second, it keeps a vector character
 strings that correspond to the names of each of the categories.
 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# A charater vector
\end_layout

\begin_layout Plain Layout

y <- c('B','B','A','A','C')
\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# convert the vector of characters into a vector of factors 
\end_layout

\begin_layout Plain Layout

z <- factor(y)
\end_layout

\begin_layout Plain Layout

str(z)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Notice that the vector 
\family typewriter
z
\family default
 is actually the combination of group assignment vector 
\family typewriter
2,2,1,1,3
\family default
 and the group names vector 
\family typewriter

\begin_inset Quotes eld
\end_inset

A
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

B
\begin_inset Quotes erd
\end_inset

,
\begin_inset Quotes erd
\end_inset

C
\begin_inset Quotes erd
\end_inset


\family default
.
 So we could convert 
\family typewriter
z
\family default
 to a vector of numerics or to a vector of character strings.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

as.numeric(z)
\end_layout

\begin_layout Plain Layout

as.character(z)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Often we need to know what possible groups there are, and this is done using
 the 
\family typewriter
levels()
\family default
 command.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

levels(z)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that the order of the group names was done alphabetically, which
 we did not chose.
 This ordering of the levels has implications when we do an analysis or
 make a plot and R will always display information about the factor levels
 using this order.
 It would be nice to be able to change the order.
 Also it would be really nice to give more descriptive names to the groups
 rather than just the group code in my raw data.
 I find it is usually easiest to just convert the vector to a character
 vector, and then convert it back using the 
\family typewriter
levels
\family default
 argument to define the order of the groups, and 
\family typewriter
labels
\family default
 to define the modified names.
 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

z <- factor(z, levels=c('B','A','C'), labels=c("B Group", "A Group", "C
 Group"))
\end_layout

\begin_layout Plain Layout

z
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Often we wish to take a continuous numerical vector and transform it into
 a factor.
 The function 
\family typewriter
cut()
\family default
 takes a vector of numerical data and creates a factor based on your give
 cut-points.
 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# Define a continuous vector to convert to a factor
\end_layout

\begin_layout Plain Layout

x <- 1:10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# divide range of x into three groups of equal length
\end_layout

\begin_layout Plain Layout

cut(x, breaks=3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# divide x into four groups, where I specify all 5 break points
\end_layout

\begin_layout Plain Layout

# Notice that the the outside breakpoints must include all the data points.
\end_layout

\begin_layout Plain Layout

# That is, the smallest break must be smaller than all the data, and the
 largest
\end_layout

\begin_layout Plain Layout

# must be larger (or equal) to all the data.
\end_layout

\begin_layout Plain Layout

cut(x, breaks = c(0, 2.5, 5.0, 7.5, 10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# divide x into 3 groups, but give them a nicer
\end_layout

\begin_layout Plain Layout

# set of group names
\end_layout

\begin_layout Plain Layout

cut(x, breaks=3, labels=c('Low','Medium','High'))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Logicals
\end_layout

\begin_layout Standard
Often I wish to know which elements of a vector are equal to some value,
 or are greater than something.
 R allows us to make those tests at the vector level.
 
\end_layout

\begin_layout Standard
Very often we need to make a comparison and test if something is equal to
 something else, or if one thing is bigger than another.
 To test these, we will use the 
\family typewriter
<, <=, ==, >=, >,
\family default
 and 
\family typewriter
!=
\family default
 operators.
 These can be used similarly to
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

6 < 10    # 6 less than 10?
\end_layout

\begin_layout Plain Layout

6 == 10   # 6 equal to 10?
\end_layout

\begin_layout Plain Layout

6 != 10   # 6 not equal to 10?
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

where we used 6 and 10 just for clarity.
 The result of each of these is a logical value (a TRUE or FALSE).
 In most cases these would be variables you had previously created and were
 using.
 Assign values to variable 
\family typewriter
a
\family default
 and to variable 
\family typewriter
b
\family default
 and test if 
\family typewriter
a < b
\family default
.
\end_layout

\begin_layout Standard
Suppose I have a vector of numbers and I want to get all the values greater
 than 16.
 Using the 
\family typewriter
>
\family default
 comparison, I can create a vector of logical values that tells me if the
 specified value is greater than 16.
 The 
\family typewriter
which()
\family default
 takes a vector of logicals and returns the indices that are true.
 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- 1:20  # a vector of 20 integers
\end_layout

\begin_layout Plain Layout

x > 16     # a vector of 20 logicals
\end_layout

\begin_layout Plain Layout

indices <- which( x > 16 )
\end_layout

\begin_layout Plain Layout

indices
\end_layout

\begin_layout Plain Layout

x[ indices ]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
On function I find to be occasionally useful is the 
\family typewriter
is.element
\family default
 function which allows me to figure out which elements of a vector are one
 of a set of possibilities.
 For example, I might want to know which elements of the 
\family typewriter
letters
\family default
 vector are vowels.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

letters  # recall this is all 26 english lowercase letters
\end_layout

\begin_layout Plain Layout

vowels <- c('a','e','i','o','u')
\end_layout

\begin_layout Plain Layout

which( is.element(letters, vowels) )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

This shows me the vowels occur at the 1st, 5th, 9th, 15th, and 21st elements
 of the alphabet.
\end_layout

\begin_layout Standard
Often I want to make multiple comparisons, for example maybe I want to find
 all undergraduate Forestry majors with a GPA greater than 3.0.
 Then give my set of university students I want ask two questions: Is their
 major Forestry, and is their GPA greater than 3.0.
 So I need to combine those two logical results into a single logical that
 is true if 
\emph on
both
\emph default
 questions are true.
 The command 
\family typewriter
&
\family default
 means 
\begin_inset Quotes eld
\end_inset

and
\begin_inset Quotes erd
\end_inset

 and 
\family typewriter
|
\family default
 means 
\begin_inset Quotes eld
\end_inset

or
\begin_inset Quotes erd
\end_inset

.
 We can combine two logical values using these two similarly: 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

TRUE  & TRUE     # both are true so combo so result is true
\end_layout

\begin_layout Plain Layout

TRUE  & FALSE    # one true and one false so result is false
\end_layout

\begin_layout Plain Layout

FALSE & FALSE    # both are false so the result is false
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

TRUE  | TRUE     # at least one is true -> TRUE
\end_layout

\begin_layout Plain Layout

TRUE  | FALSE    # at least one is true -> TRUE
\end_layout

\begin_layout Plain Layout

FALSE | FALSE    # neither is true -> FALSE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Exercises
\end_layout

\begin_layout Enumerate
Create a vector of character strings with six elements
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

test <- c('red','red','blue','yellow','blue','green')
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Transform the 
\family typewriter
test
\family default
 vector just you created into a factor.
\end_layout

\begin_layout Enumerate
Use the 
\family typewriter
levels()
\family default
 command to determine the levels (and order) of the factor you just created.
 
\end_layout

\begin_layout Enumerate
Transform the factor you just created into integers.
 Comment on the relationship between the integers and the order of the levels
 you found in part (b).
\end_layout

\begin_layout Enumerate
Use some sort of comparison to create a vector that identifies which factor
 elements are the 
\family typewriter
red
\family default
 group.
\end_layout

\end_deeper
\begin_layout Enumerate
Given the vector of ages, 
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

ages <- c(17, 18, 16, 20, 22, 23)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

create a factor that has levels 
\family typewriter
Minor
\family default
 or 
\family typewriter
Adult
\family default
 where any observation greater than or equal to 18 qualifies as an adult.
\end_layout

\begin_layout Enumerate
Suppose we vectors that give a students name, their GPA, and their major.
 We want to come up with a list of forestry students with a GPA of greater
 than 3.0.
\begin_inset Newline newline
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

Name <- c('Adam','Benjamin','Caleb','Daniel','Ephriam', 'Frank','Gideon')
\end_layout

\begin_layout Plain Layout

GPA <- c(3.2, 3.8, 2.6, 2.3, 3.4, 3.7, 4.0)
\end_layout

\begin_layout Plain Layout

Major <- c('Math','Forestry','Biology','Forestry','Forestry','Math','Forestry')
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Create a vector of 
\family typewriter
TRUE/FALSE
\family default
 values that indicate whether the students GPA is greater than 3.0.
\end_layout

\begin_layout Enumerate
Create a vector of 
\family typewriter
TRUE
\family default
/
\family typewriter
FALSE
\family default
 values that indicate whether the students' major is forestry.
\end_layout

\begin_layout Enumerate
Create a vector of 
\family typewriter
TRUE/FALSE
\family default
 values that indicates if a student has a GPA greater than 3.0 
\emph on
and
\emph default
 is a forestry major.
\end_layout

\begin_layout Enumerate
Convert the vector of 
\family typewriter
TRUE/FALSE
\family default
 values in part (c) to integer values using the 
\family typewriter
as.numeric()
\family default
 function.
 Which numeric value corresponds to 
\family typewriter
TRUE
\family default
?
\end_layout

\begin_layout Enumerate
Sum (using the 
\family typewriter
sum()
\family default
 function) the vector you created to count the number of students with GPA
 > 3.0 and are a forestry major.
\end_layout

\end_deeper
\begin_layout Enumerate
Make two variables, and call them 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 where 
\family typewriter
a=2
\family default
 and 
\family typewriter
b=10
\family default
.
 I want to think of these as defining an interval.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Define the vector 
\family typewriter
x <- c(-1, 5, 12)
\end_layout

\begin_layout Enumerate
Using the 
\family typewriter
&
\family default
, come up with a comparison that will test if the value of 
\begin_inset Formula $x$
\end_inset

 is in the interval 
\begin_inset Formula $[a,b]$
\end_inset

.
 (We want the test to return TRUE if 
\begin_inset Formula $a\le x\le b$
\end_inset

).
 That is, test if a is less than x and if x is less than b.
 Confirm that for 
\family typewriter
x
\family default
 defined above you get the correct vector of logical values.
 
\end_layout

\begin_layout Enumerate
Similarly make a comparison that tests if x is outside the interval 
\begin_inset Formula $[a,b]$
\end_inset

 using the 
\family typewriter
|
\family default
 operator.
 That is, test if x < a or x > b.
 I want the test to return TRUE is x is less than a or if x is greater than
 b.
 Confirm that for 
\family typewriter
x
\family default
 defined above you get the correct vector of logical values.
 
\end_layout

\end_deeper
\end_body
\end_document
